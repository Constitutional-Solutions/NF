// legion_core_rs/src/lib.rs
use pyo3::prelude::*;
use std::f64::consts::PI;

// 1. UNIVERSAL CONSTANTS (Hardcoded in Rust for Speed)
const PHI: f64 = 1.618033988749895;
const HBAR: f64 = 1.054571817e-34;

// 2. QUANTUM HARMONIC ENGINE (Port of quantum.py)
#[pyclass]
struct QuantumEngineRS {
    fib_cache: Vec<u64>,
}

#[pymethods]
impl QuantumEngineRS {
    #[new]
    fn new() -> Self {
        // Pre-calculate Fibonacci for instant lookups
        let mut fib = vec![0, 1];
        for i in 0..50 {
            let next = fib[i] + fib[i+1];
            fib.push(next);
        }
        QuantumEngineRS { fib_cache: fib }
    }

    // Calculates Energy Eigenvalue 100x faster than Python
    fn energy_eigenvalue(&self, n: i32, omega: f64) -> PyResult<f64> {
        Ok(HBAR * omega * (n as f64 + 0.5))
    }

    // Quantize Phi instantly
    fn phi_quantization(&self) -> PyResult<(u64, u64)> {
        let base_144k = (PHI * 144_000.0) as u64;
        let quantum_state = (PHI * 100.0) as u64;
        // Find nearest fib (Rust vector search is blazing fast)
        let nearest_fib = self.fib_cache.iter()
            .min_by_key(|&x| ((*x as i64) - (quantum_state as i64)).abs())
            .unwrap();
        
        Ok((base_144k, *nearest_fib))
    }
}

// 3. PATTERN MATH ENGINE (Port of pattern_math.py)
#[pyclass]
struct PatternEngineRS {}

#[pymethods]
impl PatternEngineRS {
    #[staticmethod]
    fn quadratic_growth_stream(input_val: f64) -> PyResult<Vec<f64>> {
        // "Variable-Less" execution trace
        let dup = input_val;
        let square = input_val * input_val;
        let double = input_val * 2.0;
        let combine = square + double;
        let unity = combine + 1.0;
        
        Ok(vec![input_val, square, double, combine, unity])
    }
}

// EXPOSE TO PYTHON
#[pymodule]
fn legion_core_rs(_py: Python, m: &PyModule) -> PyResult<()> {
    m.add_class::<QuantumEngineRS>()?;
    m.add_class::<PatternEngineRS>()?;
    Ok(())
}
